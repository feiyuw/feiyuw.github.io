---
layout: post
title:  "自己动手编写持续交付软件"
date:   2016-02-04 10:00:00
categories: Programming
---
## 前言
[持续交付系统](https://en.wikipedia.org/wiki/Continuous_delivery)或者[持续集成系统](https://en.wikipedia.org/wiki/Continuous_integration)是现代软件开发不可或缺的基础设施，尤其在大型项目中，**持续交付系统**的质量和效率往往极大影响开发的质量和效率。许多大型软件项目甚至有一个或多个专门的团队来开发和维护这类系统。另外，**持续交付系统**包含软件研发中的大量一手数据，很好地挖掘这些数据，也可以得到很多有价值的信息。

市面上有很多商业和开源的持续交付解决方案，如[Bambook](https://www.atlassian.com/software/bamboo/)，[Jenkins](http://jenkins-ci.org)，与github深度集成的[Travis-CI](http://travis-ci.org)，面向创业团队的[CodeShip](https://codeship.com/)，酷酷的[Drone-CI](https://drone.io/)等。另外在8.0+版本的[gitlab](http://gitlab.org)里也将gitlab-ci集成了进去，作为内置的持续交付平台。

既然已经有这么多现成的工具了，那么为什么我们还要自己写一套持续交付系统呢？换言之，你为什么要重复造轮子？

重复造轮子这顶帽子太大，咱们只是在重复实现轮子，因为：

1. 写一个持续交付系统很有趣
1. 可以通过编写这个系统来实践分布式系统的搭建
1. 可以完美适配自己的开发流程
1. 可以整合其他既有的资源，如报表系统等
1. 可以拿来吹牛～～

那么，一个**持续交付系统**需要包含哪些基本功能呢？

1. 能够集成版本控制工具如[subversion](http://subversion.apache.org/)、[git](http://git-scm.com/)
1. 能够将任务分发到多个节点上执行
1. 可以定制执行的内容
1. 能够保存执行的日志
1. 能够方便地查看执行的结果和日志
1. 能够及时地发送反馈和通知

所以，一个**持续交付系统**至少具有：

1. 一个可视化的界面（通常是Web）
1. 一个数据库或文件系统（用于保存配置和执行结果）
1. 一个节点管理和分发工具（用于将任务分发到不同节点上执行）
1. 一个定时任务工具（用于检测代码版本的变化和发送通知等）

这里，笔者希望通过一个具体的例子来展示一下如何开发一个持续交付系统。这个进行中的项目叫`lybica`，它的地址在[lybicat@github](http://github.com/lybicat/)，目前它还是一个玩具，将来，谁知道呢？

---

## 从界面开始

### 第一个页面

在开始设计界面之前，让我们先回答一个问题：假设只能有一个页面，这个页面该展示什么？此处默念三十秒。。。

`lybica`的第一个页面是任务队列（包括没开始执行的、执行中的和已经结束的任务）。最基本的部分就是一个包含所有task的表格，如下图：

![task list]({{ site.url }}/assets/cd-tasks.png)

在这个页面上，一个Task包含如下信息：

1. 状态(pending, running, pass, failed, aborted)
1. 目标版本（这里叫Build，本质上跟Revision类似）
1. 执行计划（对应与Jenkins里的Job，包含执行内容等配置）
1. 执行节点（这个任务将会被分配到的目标节点）
1. 触发源（如Git的变化、手工触发、按时间触发等）
1. 创建时间
1. 相应的操作（如Rerun，Abort等）
1. 相应的资源链接（如Console Output，Log Artifacts等）

其实这里隐含这我们的第一个用户场景，可能也是最重要的那个：

>作为一个开发者，当我在持续交付系统上注册了我的项目，并且配置好了相应的执行计划后，我希望当这个计划被执行后能够生成任务，并且我能够看到任务的各种信息，如成功、失败，相应的日志等。

这样，我们知道，对于上面这个用户场景，除了上面这个任务页面之外，我们可能还需要以下几个页面来满足它：

1. 执行计划的查看和编辑页面
1. 触发执行计划的查看和配置页面
1. 实时查看某一个任务进度的页面

---

### 执行计划页面

这个页面包含两个基本的功能：查看和编辑。其中编辑又包含新增、修改和删除等功能。我们先看查看功能，它类似于任务列表，所以可以如下图这样实现：

![plan list]({{ site.url }}/assets/cd-plans.png)

在这个页面上，我们可以看到，一个plan包含：

1. 名字（通常是唯一的）
1. 测试集合
1. 执行环境
1. 修改按钮
1. 执行按钮

而编辑方面，新增和修改可以合二为一，而删除可以在修改的时候加一个删除按钮。这样整个编辑功能可以简化为一个表单加一个新增按钮，如下图：

![plan edit]({{ site.url }}/assets/cd-plan-edit.png)

而在编辑页面，我们发现，除了查看页面里展示的那些信息之外，一个plan还需要包括：

1. 执行内容，这里称之为Actions
1. 变量设置，这个截图上没有展示，但在实际应用中非常重要

我们最终的实现将查看和编辑合在了一个页面上，编辑表单默认隐藏，点击编辑按钮才会显示。

---

### 触发器查看和管理页面

触发执行计划的功能，我们称之为触发器（Trigger）。

熟悉Jenkins的人都知道，Jenkins有很多的Trigger插件，可以支持各种的触发条件（如Subversion，Git，URL Change等）。Jenkins的触发采用的是一种轮询方式，最小粒度为1分钟，当两次轮询的结果发生变化，即产生新的任务。对于轮询间隔内究竟发生了几次变化，Jenkins并不关心，它只会采用最后的一次变化的版本，这一点跟gitlab-ci和travis这样的不一样，在gitlab-ci中，没一个commit都会被触发，无论其间隔是多少。

另一种常见的触发方式是按时间触发，最典型的就是cron，比如每天晚上8：00开始进行构建。

基于这些考虑，在触发器的设计上，我们考虑三种不同形式的触发器：

1. 事件轮询
1. 类似cron的调度方式
1. 类似webhook的事件触发（通常来自于外部如gitlab）

类似webhook的事件触发不需要具体的配置界面，有一个API接口就OK了，关于这一部分，我们在后续详细介绍触发机制的时候说明。

对于`事件轮询`的页面，同样包含查看和编辑两个部分，参照执行计划页面的做法，我们把两者合一，见下图：

![trigger page]({{ site.url }}/assets/cd-triggers.png)

相对于Plan来说，Trigger多了一个disable/enable的功能，其它方面基本一致。

---

### Console Output页面

对于实时查看某一个任务的进度和输出，参照Jenkins的命名方式，我们也叫它为`Console Output`。所以这个页面的要求是：

1. 与task关联
1. 实时更新输出

可以很简单，如下图：

![console output]({{ site.url }}/assets/cd-console.png)

## 数据的保存

[TODO]

---

## 执行日志的存储

[TODO]

---

## 实时查看执行的结果

Jenkins的实现方式是，所有的job的`Console Output`都是以文件形式存储在Jenkins Master上的，通过管道的方式把输出不断地append到那个名叫log的文件中。所以在Jenkins上，如果job很多，build次数很多，IO性能会有比较大的影响，有一部分原因就是因为它所有的builds和console output都是以文件形式存储在master上的。
[TODO]

---

## 如何管理执行节点

[TODO]

---

## 如何集成现有的版本控制工具

[TODO]

---

## 如何优雅地部署和升级

[TODO]

